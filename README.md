# 🏛️ Fundamentos da Engenharia de Software

Bem-vindo! Este repositório é um guia de referência centralizado, dedicado a documentar os **princípios, conceitos e pilares universais da engenharia de software**.

O objetivo é criar uma base de conhecimento atemporal e agnóstica, que sirva de apoio para desenvolvedores de todos os níveis, independentemente da linguagem de programação, framework ou arquitetura que utilizem no dia a dia.

---

## 🧭 Tópicos Abordados

A estrutura deste repositório foi pensada para organizar os conceitos de forma lógica e progressiva.

-   **📜 Princípios de Design**:
    -   Conceitos fundamentais para escrever código limpo, manutenível e flexível, como SOLID, DRY, KISS e YAGNI.

-   **🏗️ Arquitetura de Software**:
    -   Estudo de padrões arquiteturais (Monolito, Microserviços), estilos (REST), e conceitos de design de alto nível como a Arquitetura Limpa (Clean Architecture).

-   **🧩 Padrões de Projeto (Design Patterns)**:
    -   Soluções reutilizáveis para problemas comuns no desenvolvimento de software, categorizadas em Criacionais, Estruturais e Comportamentais.

-   **🧬 Algoritmos e Estruturas de Dados**:
    -   A base da ciência da computação, incluindo análise de complexidade (Big O), e o estudo das principais estruturas de dados e algoritmos.

-   **🔄 Ciclo de Vida do Desenvolvimento de Software (SDLC)**:
    -   Visão geral dos modelos de processo de software, como Ágil (Scrum, Kanban) e tradicional (Cascata), e disciplinas como engenharia de requisitos.

-   **✅ Qualidade e Testes**:
    -   Estratégias e conceitos para garantir a qualidade do software, incluindo a pirâmide de testes, tipos de teste e metodologias como TDD e BDD.

-   **🌐 Paradigmas de Programação**:
    -   Uma visão geral dos diferentes modelos de programação, como Orientado a Objetos, Funcional e Estruturado.

---

## Estrutura de Diretórios

/
├── 📜 principios-de-design/
│   ├── solid.md
│   ├── dry.md
│   ├── kiss.md
│   └── yagni.md
│
├── 🏗️ arquitetura-de-software/
│   ├── padroes-arquiteturais.md (Monolito, Microserviços, Cliente-Servidor...)
│   ├── arquitetura-limpa.md (Clean Architecture)
│   └── comunicacao-entre-servicos.md (REST, gRPC, Mensageria...)
│
├── 🧩 padroes-de-projeto/ (Design Patterns)
│   ├── criacionais/ (Factory, Singleton, Builder...)
│   ├── estruturais/ (Adapter, Facade, Decorator...)
│   └── comportamentais/ (Strategy, Observer, Command...)
│
├── 🧬 algoritmos-e-estruturas-de-dados/
│   ├── complexidade-de-algoritmo.md (Big O Notation)
│   ├── estruturas-de-dados.md (Arrays, Listas, Pilhas, Filas, Árvores...)
│   └── algoritmos-de-busca-e-ordenacao.md
│
├── 🔄 ciclo-de-vida-do-software/ (SDLC)
│   ├── modelos-de-desenvolvimento.md (Cascata, Ágil, Scrum, Kanban...)
│   └── engenharia-de-requisitos.md
│
├── ✅ qualidade-e-testes/
│   ├── tipos-de-teste.md (Unitário, Integração, E2E...)
│   ├── piramide-de-testes.md
│   └── tdd-e-bdd.md
│
└── 🌐 paradigmas-de-programacao/
    ├── orientado-a-objetos.md
    ├── funcional.md
    └── estruturado.md

---

## 🤝 Como Contribuir

Este é um projeto vivo e contribuições são muito bem-vindas! Se você encontrar um erro, tiver uma sugestão de melhoria ou quiser adicionar um novo tópico, sinta-se à vontade para abrir uma **Issue** ou enviar um **Pull Request**.

1.  Faça um **Fork** deste repositório.
2.  Crie uma nova **Branch** para sua modificação (`git checkout -b minha-contribuicao`).
3.  Faça o **Commit** de suas alterações (`git commit -m 'feat: Adiciona conteúdo sobre X'`).
4.  Envie para a sua branch (`git push origin minha-contribuicao`).
5.  Abra um **Pull Request**.
